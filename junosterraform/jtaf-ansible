#!/usr/bin/env python3
import xml.etree.ElementTree as ElementTree
import json
import argparse
import sys
from jinja2 import Template
import os
import os
from importlib.resources import files, as_file
import yaml

def get_xpaths(root):
    # defined a recursive function to walk the xml and populate result[]
    def recurse_children(node, result = {}, path = []):
        for child in node:
            path.append(child.tag)
            recurse_children(child, result, path)
        result['/'.join(path)] = True
        # before we leave here remove the last path element
        if len(path) > 0:
            del path[-1]
        return result
    # run the search and return the result
    return recurse_children(root)
 
def unique_xpaths(paths):
    path_dict = {}
    result = []

    for path in paths:
        if path == "groups/name":
            # Skip the groups/name path entirely
            continue
        elif path.startswith("groups"):
            # Remove the "groups/" prefix from other paths
            path = path[len("groups/"):]
        
        # Only add non-empty paths
        if path:
            path_dict[path] = path
    
    for key in path_dict.keys():
        result.append(path_dict[key])
    return result
 
def get_path(parent):
    path = ''
    for i in parent:
        if isinstance(i, dict) and "name" in i:
            path += "/" + i["name"]
    tmp_list = path.split("/")[3:]
    path = "/".join(tmp_list)
    return path
 
def check_path(paths, node):
    path = get_path(node)
    if path in paths or path =='':
        return True
    return False
 
def check_for_choice(elem):
    cases = []
    children = []
    if elem["type"] == "choice":
        # node of type choice but do not have any children e.g. vstp-flooding-option
        if "children" not in elem.keys():
            return children
        for k in elem["children"]:
            cases.append(k)
        for case in cases:
            if "children" in case.keys():
                children.append(case["children"])
    return children

def check_for_enums(elem, node_parent):
    cases =[]
    children = []
    if elem["name"] == 'choice-ident' and elem["type"] == 'leaf':
        for k in elem["enums"]:
            # this fix for especially for community-name which is present in enums as well child outside enums
            if k['id'] not in node_parent[-2]['key']:
                cases.append(k)
        for case in cases:
            tmp_dict = {}
            tmp_dict['name'] = case['id']
            tmp_dict['type'] = 'leaf'
            tmp_dict['leaf-type'] = 'string'
            children.append(tmp_dict)
    return children
        
def check_children(paths, elem, node_parent, current_path):
    if isinstance(node_parent[-2], dict):
        if "children" in node_parent[-2].keys():
            if isinstance(elem, dict):
                elem_path = ''
                if current_path == '':
                    elem_path = elem['name']
                else:
                    elem_path = current_path + "/" + elem["name"]
 
            if elem_path in paths or elem_path == 'configuration':
                    # This code handles the logic for paths that are directly in the config
                    # and are not choices or enums
                return True
            else:
                # This code handles the logic for paths that aren't directly in the config but follow type 'choice' which leads to that path
                choices = check_for_choice(elem)
                enums = check_for_enums(elem, node_parent)
                if choices:
                    choice_list =[]
                    for choice in choices:
                        temp_path = current_path + "/" + choice[0]["name"]
                        if temp_path in paths:
                            choice_list.append(choice)
                    return choice_list   
                if enums:
                    enums_list = []
                    for enum in enums:
                        temp_path = current_path + "/" + enum["name"]
                        if temp_path in paths:
                            enums_list.append(enum)
                    return enums_list
        else:
            return True
    else:
        return True
    return False

def remove_tags_by_name(root, tag_names):
    # Recursively remove all nodes with matching tag names 
    for tag in tag_names:
        for elem in root.findall(f".//{tag}"):
            parent = find_parent(root, elem)
            if parent is not None:
                parent.remove(elem)

def find_parent(root, child):
    # Find parent of a given element 
    for parent in root.iter():
        for elem in parent:
            if elem is child:
                return parent
    return None
 
def walk_schema(paths, node, parent = []):
    result = None
    emit_data = check_path(paths, parent)
    current_path = get_path(parent)
    if isinstance(node, dict):
        node['path'] = current_path
        result = {}
        parent.append(node)
        for k in node.keys():
            if emit_data:                
                # Node with empty children list is continued as type container or list just that no children element is missing'       
                tmp_result = walk_schema(paths, node[k], parent)
                if isinstance(tmp_result, list) and len(tmp_result) == 0:
                    continue
                else:
                    result[k] = walk_schema(paths, tmp_result, parent)

        parent.pop()
    elif isinstance(node, list):
        result = []
        parent.append(node)
        for elem in node:
            # UPDATE: This code now handles choice options --> vlan_tagging and vlan_id now included
            result_val = check_children(paths, elem, parent, current_path)
            if isinstance(result_val, list):
                for item in result_val:
                    if isinstance(item, list):
                        item[0]['path'] = current_path
                        result.append(item[0])
                    elif isinstance(item, dict):
                        item['path'] = current_path
                        result.append(item)
            elif isinstance(result_val, dict):
                result_val['path'] = current_path
                result.append(result_val)                         
            else:
                if isinstance(result_val, bool):
                    if result_val:                          
                        result.append(walk_schema(paths, elem, parent))

        parent.pop()
    else:
        result = node
    return result
 
# Method which starts the walk
def filter_json_using_xml(schema, xml):
    if schema == "-":
        schema = json.load(sys.stdin)
    else:
        with open(schema) as f:
            schema = json.load(f)

    # Check if xml is a single file or merged xml element 
    if isinstance(xml, str):
        with open(xml) as f:
            xml_text = f.read()
        # Parse XML under temporary root
        root = ElementTree.fromstring(f"<root>{xml_text}</root>")
    else:
        root = xml

    # Try to find the <configuration> node under <rpc-reply>
    config_node = root.find(".//configuration")
    if config_node is not None:
        # set the config node to be root
        root = config_node

    # find and remove any version node
    remove_tags_by_name(root, ["version", "versions", "model", "apply-groups"])

    # find the unique paths
    paths = unique_xpaths(get_xpaths(root))

    new_schema = walk_schema(paths, schema)
    return new_schema
 

def load_and_merge_xmls(xml_file_list):
    merged_config = ElementTree.Element("configuration")

    # Parse and find <configuration> in each file
    for path in xml_file_list:
        with open(path) as f:
            raw = f.read()
        root = ElementTree.fromstring(f"<root>{raw}</root>")
        config = root.find(".//configuration")
        if config is None:
            raise ValueError(f"No <configuration> found in {path}")
        for child in config:
                merged_config.append(child)

    return merged_config


#CURRENT_LEVEL=0

def prepare_tag(tag):
    """Prepare XML tag to be used as YAML key by replacing '-' and '.' with '_'."""
    return tag.replace("-", "_").replace(".", "_")

def element_node(element,path,resources):
    """Return the resource node matching the given XML element and path.
    Args:
        element: XML element to match
        path: path to match in the schema
        resources: schema resource node to search
    Returns:
        The matching resource node or None if not found
    """
    
 #   print(f"RESOURCES_PATH={resources.get("path")} TYPE={resources.get("type")} NAME={resources.get("name")} ELEMENT={element} TAG={element.tag} TEXT=|{element.get('text')}| PATH={path} ")
    if resources['name'] == element.tag and (resources.get("path") is None or (resources["path"]+'/'+element.tag)==path):
 #       print(f"FOUND MATCH FOR ELEMENT={element} TYPE={resources['type']} PATH={path}")
        return {k: v for k, v in resources.items() if k != "children"}
    try:
        for elem in resources["children"]:
    #        if elem['name'] == element['name'] and path==elem['path']:
    #            return elem['type']
    #        if elem['type'] != 'leaf':
                etype=element_node(element,path,elem)
                if etype:
                    return etype                  
    except KeyError:
        return None            
    return None

def elem_to_dict(element,path,resources):
    """Convert an XML element and its children to a dictionary.
    Args:
        element: XML element to convert
        path: current path of the element. Needed to uniquely identify the element in the schema
        resources: schema resource node to use for type information
    Returns:
        A dictionary representation of the XML element
    """
    
    result = {}
 #   global CURRENT_LEVEL
 #   CURRENT_LEVEL+=1
 #   cnt=0
 #   print(f"CURRENT_LEVEL={CURRENT_LEVEL} ELEMENT={element} ")
    for child in element:
        prepared_tag=prepare_tag(child.tag)
        prepared_path=child.tag            
        if len(path)>0:
            prepared_path=path+'/'+child.tag
        elem_node=element_node(child,prepared_path,resources)    
        elem_type=elem_node['type'] if elem_node else None
 #       print(f"ELEM_NODE={elem_node} ELEM_TYPE={elem_type} FOR CHILD={child.tag} PATH={prepared_path} ")
  #      if child.tag=='interface':
  #              print(f"Processing interface element: {ElementTree.tostring(child)}")
  #              print(f"CURRENT_LEVEL={CURRENT_LEVEL} result[prepared_tag]={result.get(prepared_tag)} elem_type={elem_type}")
        if elem_type == 'list':
            # If the element is of type list, always create a list
            
            if not result.get(prepared_tag):
                result[prepared_tag] = []
            if len(child) > 0:
                result[prepared_tag].append(elem_to_dict(child,prepared_path,resources))
            else:
                result[prepared_tag].append(child.text)
        elif elem_type == 'leaf-list':
            # If the element is of type leaf-list, always create a list
            if not result.get(prepared_tag):
                result[prepared_tag] = []
            result[prepared_tag].append(child.text)        
        elif elem_type == 'container':
            # If the element is of type container, always create a dict
            if len(child) > 0:
                result[prepared_tag] = elem_to_dict(child,prepared_path,resources)
            else:
                result[prepared_tag] = {}
        else:
            # For other types, decide based on children
            if len(child) > 0:
                result[prepared_tag] = elem_to_dict(child,prepared_path,resources)
            else:
                if elem_type=='leaf':
                    if elem_node['leaf-type']=='empty':
                        result[prepared_tag] = True
                    else:    
                        result[prepared_tag] = child.text
                else:
                    result[prepared_tag] = child.text     
#       cnt+=1      
#    if not cnt:
#        result[element.tag] = element.text    
#    CURRENT_LEVEL-=1    
    return result

def xml2yaml(xml_file, resources,output_dir, subdir=None):
    """Convert an XML configuration file to YAML format using the provided schema resources.
    Output file name is derived from the XML file name by changing the extension to .yaml.
    Args:
        xml_file: Path to the XML configuration file
        resources: Schema resource node to use for conversion
        output_dir: Directory to save the converted YAML file"""
        
    with open(xml_file) as f:
        raw = f.read()
    root = ElementTree.fromstring(f"<root>{raw}</root>")
    hostname = xml_file.split('.')[0]
    hostname_elem = root.find(".//system/host-name")
    if hostname_elem is not None and hostname_elem.text:
        hostname = hostname_elem.text  
    config = root.find(".//configuration")
    if config is None:
        raise ValueError(f"No <configuration> found in {xml_file}")
    if subdir:
        output_dir = os.path.join(output_dir, subdir)
    xml_dict = elem_to_dict(config,"",resources['root'])
    yaml_output = yaml.dump(xml_dict, sort_keys=False)
    base_name = os.path.basename(xml_file)
#    yaml_file_name = os.path.splitext(base_name)[0] + ".yaml"
    yaml_file_name = hostname + ".yaml"
    output_path = os.path.join(output_dir, yaml_file_name)
    os.makedirs(output_dir, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(yaml_output)
    return hostname    
#    print(f"Converted {xml_file} to {output_path}")
    
# Main Method
def main():
    # other arguments
    parser = argparse.ArgumentParser(exit_on_error=True)
    parser.add_argument('-j', '--json-schema', required=True, help='specify the json schema file')
    parser.add_argument('-x', '--xml-config', required=True, action='append', nargs="+", help='specify one or more XML config files to combine')
    parser.add_argument('-t', '--type', required=True, help='device type (i.e. vsrx, mx960, ex4200, etc)')
    args = parser.parse_args()

    # Merge XML files if multiple are provided 
    xml_files = [file for group in args.xml_config for file in group]
    xml_config = xml_files[0] if len(xml_files) == 1 else load_and_merge_xmls(xml_files)

    # Step 1: Filter the schema using the config
    resources = filter_json_using_xml(args.json_schema, xml_config)

    # Step 2: Render the template into Jinja2 code
    with as_file(files('junosterraform').joinpath('__init__.py')) as init_py:
        package_dir = os.path.dirname(init_py)
    templates_dir = f"{package_dir}/templates"
    with open(f"{templates_dir}/ansible.j2") as f:
        jinja2_source = f.read()
    tmpl = Template(jinja2_source)
    resource_config_provider_j2 = tmpl.render(data=resources).lstrip()

    # Step 3: Prepare new output directory based on type
    with as_file(files('terraform_provider').joinpath('__init__.py')) as init_py:
       j2_dir = os.path.dirname(init_py)
    new_dir = f"ansible-provider-junos-{args.type}"

# create roles/<rolename>/{tasks,templates} structure
    role_name = f"{args.type}_role"
    roles_path = os.path.join(new_dir, "roles", role_name)
    
    tasks_path = os.path.join(roles_path, "tasks")
    templates_path = os.path.join(roles_path, "templates")
    os.makedirs(tasks_path, exist_ok=True)
    os.makedirs(templates_path, exist_ok=True)

    # write a minimal tasks/main.yml
    tasks_main = f"""- name: Applying template for {role_name}
  template: src=template.j2 dest={{{{ tmp_dir }}}}/{{{{ inventory_hostname }}}}.xml
"""
    with open(os.path.join(tasks_path, "main.yml"), "w") as f:
        f.write(tasks_main)

    # copy rendered main.j2 into the role templates as an example
    with open(os.path.join(templates_path, "template.j2"), "w") as f:
        f.write(resource_config_provider_j2)


    # Step 4: Generate YAML files from XML configs and hosts file
    hostnames=[]
    for xml_file in xml_files:
        hostnames.append(xml2yaml(xml_file,resources, new_dir,"host_vars"))
    
    with open(os.path.join(new_dir, "hosts"), "w") as f:
        f.write("[all]\n")
        for hostname in hostnames:
            f.write(f"{hostname}\n")
   
   # Step 5: Create a minimal ansible playbook
    playbook_content = f"""- name: Apply Junos configuration
  hosts: all
  connection: local
  gather_facts: no
  vars:
    tmp_dir: "{{ playbook_dir }}"
  roles:
    - {role_name}
"""
    with open(os.path.join(new_dir, "jtaf-playbook.yml"), "w") as f:
        f.write(playbook_content)
# run main()
if __name__ == "__main__":
    main()